<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Quick Notes App</title>

    <!-- PWA Manifest and Theme -->
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#111827" />

    <!-- Apple PWA specific tags -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Quick Notes" />
    <link rel="apple-touch-icon" href="cropped.png" />
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel Standalone to transpile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Import Map to load React from a CDN -->
    <script type="importmap">
    {
      "imports": {
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react": "https://esm.sh/react@18.2.0"
      }
    }
    </script>

    <!-- Embedded CSS styles -->
    <style>
      /* Prevents pull-to-refresh and other default touch actions on mobile */
      body {
        overscroll-behavior-y: contain;
        touch-action: none;
      }
      #root {
        touch-action: none;
      }
      canvas {
        touch-action: none;
      }
      @keyframes fade-in {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      .animate-fade-in { animation: fade-in 0.2s ease-out forwards; }
      
      @keyframes scale-in {
        from { transform: scale(0.9) translateY(10px); opacity: 0; }
        to { transform: scale(1) translateY(0); opacity: 1; }
      }
      .animate-scale-in { animation: scale-in 0.2s ease-out forwards; }
    </style>
</head>
<body class="bg-gray-900">
    <div id="root"></div>

    <!-- The entire React application, transpiled by Babel -->
    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useEffect, useCallback } from 'react';
        import ReactDOM from 'react-dom/client';

        // --- TypeScript Enum replacement ---
        const Tool = {
          Pencil: 0,
          Text: 1,
          Eraser: 2,
        };

        // --- Icon Components (from constants.tsx) ---
        const PencilIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.5L15.232 5.232z" />
          </svg>
        );

        const TextIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2.5}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m-4.5-15h9m-9 15h9" />
          </svg>
        );

        const EraserIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M14 4 L20 9 L10 19 L4 14 Z" />
            <path strokeLinecap="round" strokeLinejoin="round" d="M6 12 L17 12" />
          </svg>
        );

        const ShareIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
          </svg>
        );

        const TrashIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
          </svg>
        );

        // --- UI Components ---

        const IconButton = ({ onClick, isActive = false, children, className = '', ariaLabel }) => {
          const baseClasses = 'p-3 rounded-full transition-all duration-200 ease-in-out transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500';
          const activeClasses = isActive ? 'bg-blue-500 text-white shadow-lg' : 'bg-white/80 text-gray-700 hover:bg-white shadow-md';
          return (
            <button onClick={onClick} className={`${baseClasses} ${activeClasses} ${className}`} aria-label={ariaLabel}>
              {children}
            </button>
          );
        };

        const Toolbar = ({ activeTool, onToolChange }) => {
          return (
            <div className="absolute bottom-5 left-1/2 -translate-x-1/2 flex items-center justify-center gap-2 bg-gray-200/50 backdrop-blur-sm p-2 rounded-full shadow-lg">
              <IconButton onClick={() => onToolChange(Tool.Pencil)} isActive={activeTool === Tool.Pencil} ariaLabel="Pencil Tool">
                <PencilIcon />
              </IconButton>
              <IconButton onClick={() => onToolChange(Tool.Text)} isActive={activeTool === Tool.Text} ariaLabel="Text Tool">
                <TextIcon />
              </IconButton>
              <IconButton onClick={() => onToolChange(Tool.Eraser)} isActive={activeTool === Tool.Eraser} ariaLabel="Eraser Tool">
                <EraserIcon />
              </IconButton>
            </div>
          );
        };

        const ConfirmationModal = ({ isOpen, onConfirm, onCancel, title, message }) => {
          if (!isOpen) return null;
          return (
            <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in">
              <div className="bg-white rounded-2xl shadow-2xl p-6 m-4 w-full max-w-sm text-center transform animate-scale-in">
                <h3 className="text-xl font-bold text-gray-800 mb-2">{title}</h3>
                <p className="text-gray-600 mb-6">{message}</p>
                <div className="flex justify-center gap-4">
                  <button onClick={onCancel} className="px-6 py-2 rounded-full text-gray-700 bg-gray-200 hover:bg-gray-300 font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                    Cancel
                  </button>
                  <button onClick={onConfirm} className="px-6 py-2 rounded-full text-white bg-red-500 hover:bg-red-600 font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2">
                    Clear
                  </button>
                </div>
              </div>
            </div>
          );
        };
        
        // --- Main App Component ---

        const App = () => {
          const [activeTool, setActiveTool] = useState(Tool.Pencil);
          const [isDrawing, setIsDrawing] = useState(false);
          const [showClearConfirm, setShowClearConfirm] = useState(false);
          const [textInput, setTextInput] = useState(null);

          const canvasRef = useRef(null);
          const contextRef = useRef(null);
          const textAreaRef = useRef(null);

          const PENCIL_COLOR = '#1f2937';
          const PENCIL_WIDTH = 3;
          const ERASER_WIDTH = 20;

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
        
            const context = canvas.getContext('2d');
            if (!context) return;
            contextRef.current = context;
        
            const setCanvasDimensions = () => {
                const tempCanvas = document.createElement('canvas');
                const tempContext = tempCanvas.getContext('2d');
                const hasContent = canvas.width > 0 && canvas.height > 0;
                
                if (hasContent) {
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    tempContext.drawImage(canvas, 0, 0);
                }
        
                const scale = window.devicePixelRatio || 1;
                canvas.width = canvas.offsetWidth * scale;
                canvas.height = canvas.offsetHeight * scale;
        
                context.scale(scale, scale);
                context.lineCap = 'round';
                context.lineJoin = 'round';
                
                context.fillStyle = 'white';
                context.fillRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
        
                if (hasContent) {
                    context.drawImage(tempCanvas, 0, 0, canvas.offsetWidth, canvas.offsetHeight);
                }
            };
            
            setCanvasDimensions();
        
            window.addEventListener('resize', setCanvasDimensions);
        
            return () => {
                window.removeEventListener('resize', setCanvasDimensions);
            };
          }, []);

          useEffect(() => {
            if (textInput?.visible && textAreaRef.current) {
                textAreaRef.current.focus();
            }
          }, [textInput]);

          useEffect(() => {
            if (textAreaRef.current) {
                textAreaRef.current.style.height = 'auto';
                textAreaRef.current.style.height = `${textAreaRef.current.scrollHeight}px`;
            }
          }, [textInput?.value]);

          const getCoords = (event) => {
            const canvas = canvasRef.current;
            if (!canvas) return null;
            const rect = canvas.getBoundingClientRect();
            
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
          };

          const handleTextCommit = useCallback(() => {
            if (!textInput || !textInput.value) {
              setTextInput(null);
              return;
            }

            const context = contextRef.current;
            if (!context) return;
            
            context.globalCompositeOperation = 'source-over';
            context.fillStyle = PENCIL_COLOR;
            context.font = '16px sans-serif';
            
            const lines = textInput.value.split('\n');
            const lineHeight = 20;
            const initialYOffset = 16;
            lines.forEach((line, index) => {
                context.fillText(line, textInput.x, textInput.y + initialYOffset + (index * lineHeight));
            });

            setTextInput(null);
          }, [textInput]);

          const startInteraction = useCallback((event) => {
            event.preventDefault();
            const coords = getCoords(event);
            if (!coords) return;
            const context = contextRef.current;
            if (!context) return;

            if (activeTool === Tool.Text) {
              if (textInput?.visible) {
                  handleTextCommit();
              }
              setTextInput({ x: coords.x, y: coords.y, value: '', visible: true, width: 200 });
              return;
            }

            setIsDrawing(true);
            context.beginPath();
            context.moveTo(coords.x, coords.y);
            
            if (activeTool === Tool.Pencil) {
              context.globalCompositeOperation = 'source-over';
              context.strokeStyle = PENCIL_COLOR;
              context.lineWidth = PENCIL_WIDTH;
            } else if (activeTool === Tool.Eraser) {
              context.globalCompositeOperation = 'destination-out';
              context.lineWidth = ERASER_WIDTH;
            }
          }, [activeTool, textInput, handleTextCommit]);

          const interact = useCallback((event) => {
            event.preventDefault();
            if (!isDrawing) return;
            const coords = getCoords(event);
            if (!coords) return;
            const context = contextRef.current;
            if (!context) return;
            
            context.lineTo(coords.x, coords.y);
            context.stroke();
          }, [isDrawing]);

          const endInteraction = useCallback(() => {
            if (!isDrawing) return;
            const context = contextRef.current;
            if (context) {
                context.closePath();
            }
            setIsDrawing(false);
          }, [isDrawing]);

          const handleClearCanvas = () => {
            const canvas = canvasRef.current;
            const context = contextRef.current;
            if (canvas && context) {
              context.save();
              context.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for clearing
              context.clearRect(0, 0, canvas.width, canvas.height);
              context.restore(); // Restore original transform
              
              // Re-apply the white background
              context.fillStyle = 'white';
              context.fillRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
            }
            setShowClearConfirm(false);
          };

          const handleShare = () => {
            const canvas = canvasRef.current;
            if (!canvas) return;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            if (!tempCtx) return;

            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.drawImage(canvas, 0, 0);

            const dataUrl = tempCanvas.toDataURL('image/jpeg', 1.0);
            
            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = `note-${Date.now()}.jpg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          };

          return (
            <div className="h-screen w-screen bg-gray-100 flex items-center justify-center p-2 sm:p-4">
              <main className="relative w-full h-full bg-white rounded-3xl shadow-2xl overflow-hidden touch-none border-4 border-gray-800">
                <canvas
                  ref={canvasRef}
                  className="w-full h-full"
                  onMouseDown={startInteraction}
                  onMouseMove={interact}
                  onMouseUp={endInteraction}
                  onMouseLeave={endInteraction}
                  onTouchStart={startInteraction}
                  onTouchMove={interact}
                  onTouchEnd={endInteraction}
                />
                {textInput?.visible && (
                    <textarea
                        ref={textAreaRef}
                        value={textInput.value}
                        onChange={(e) => setTextInput({ ...textInput, value: e.target.value })}
                        onBlur={handleTextCommit}
                        style={{
                            position: 'absolute',
                            left: `${textInput.x}px`,
                            top: `${textInput.y}px`,
                            width: `${textInput.width}px`,
                            font: '16px sans-serif',
                            lineHeight: '20px',
                            border: '1px dashed #3b82f6',
                            background: 'rgba(255, 255, 255, 0.8)',
                            outline: 'none',
                            resize: 'none',
                            overflowY: 'hidden',
                            color: PENCIL_COLOR,
                            zIndex: 10
                        }}
                        className="p-1"
                        rows={1}
                    />
                )}
                <Toolbar activeTool={activeTool} onToolChange={setActiveTool} />

                <div className="absolute bottom-5 left-5">
                    <IconButton onClick={() => setShowClearConfirm(true)} ariaLabel="Clear Canvas">
                        <TrashIcon />
                    </IconButton>
                </div>
                <div className="absolute bottom-5 right-5">
                    <IconButton onClick={handleShare} ariaLabel="Share as JPG">
                        <ShareIcon />
                    </IconButton>
                </div>
                <ConfirmationModal
                    isOpen={showClearConfirm}
                    onConfirm={handleClearCanvas}
                    onCancel={() => setShowClearConfirm(false)}
                    title="Clear Canvas"
                    message="Are you sure you want to erase everything? This action cannot be undone."
                />
              </main>
            </div>
          );
        };

        // --- Mount the App ---
        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(
          <React.StrictMode>
            <App />
          </React.StrictMode>
        );
    </script>
</body>
</html>
